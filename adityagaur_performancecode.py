# -*- coding: utf-8 -*-
"""AdityaGaur_PerformanceCode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hvrz3-tsOgU7enHZug7y9Og420v3r4eG
"""

# -----------------------------------------------------------------
# Assignment 3: RISC-V Pipeline Performance Analysis
# Course: ENCA302
#
# This script calculates the Ideal vs. Real CPI for the
# 5-stage pipelined processor based on the simulation run.
#
# [cite_start]Data Source: memfile.hex [cite: 560]
# [cite_start]Simulation: dump.vcd [cite: 1-44]
# -----------------------------------------------------------------

# --- 1. Simulation Input Data ---

# Total number of instructions loaded and executed
# [cite_start]Source: Counted from memfile.hex [cite: 560]
# (addi, addi, add, lw, addi, add)
total_instructions = 6

# Total clock cycles for the program to complete
# A 5-stage pipeline takes (N + 4) cycles for N instructions
# in the ideal (no-stall) case.
# (6 instructions + 4 cycles for last instruction to clear pipeline)
# [cite_start]This is confirmed by the simulation waveform [cite: 559-560],
# where the final 'add' instruction completes its WB stage
# in the 10th clock cycle (at timestamp 1000).
total_cycles = 10

# Ideal CPI for a 5-stage scalar pipeline
# (This is the theoretical best-case throughput)
ideal_cpi = 1.0

# --- 2. CPI Calculation ---

# Real CPI = Total Cycles / Total Instructions
real_cpi = total_cycles / total_instructions

# --- 3. Performance Evaluation & Discussion (Sub-Problem 5) ---

print("=================================================")
print("== Pipeline Performance Analysis")
print("=================================================")
print(f"Total Instructions Executed: {total_instructions}")
print(f"Total Clock Cycles Taken:    {total_cycles}")
print("---")
print(f"Ideal CPI (Theoretical):     {ideal_cpi:.2f}")
print(f"Real CPI (From Simulation):  {real_cpi:.2f}")
print("=================================================")


# ===============================================================
# --- Discussion: Causes of Stalls & Pipeline Efficiency ---
#
# (This commented discussion is the second part of Sub-problem 5)
# ===============================================================
#
# 1. Comparison of Ideal vs. Real CPI
#
# The Real CPI ({real_cpi:.2f}) is higher than the Ideal CPI (1.0).
# This is expected. The Ideal CPI of 1.0 represents the
# throughput *after* the pipeline is full.
# The Real CPI calculation is "penalized" by the initial
# 4 cycles required to fill the pipeline (the "startup cost").
#
# Efficiency = (Ideal Instructions) / (Real Cycles)
# Efficiency = (6 * 1.0) / 10 = 60.0%
#
# This 60% efficiency is low *only* because the program is
# extremely short. As the number of instructions (N) gets
# very large, the (N+4) cycle count approaches N, and
# the Real CPI approaches the Ideal CPI of 1.0.

# 2. Analysis of Stall Cycles
#
# For this specific simulation, the number of stall cycles is 0.
#
# * Data Hazards:
#     [cite_start]The instruction sequence (from memfile.hex) [cite: 560]
#     contains multiple Read-After-Write (RAW) data hazards:
#     - 'add x7, x5, x6' depends on 'addi x5' and 'addi x6'.
#     - 'add x10, x8, x9' depends on 'lw x8' and 'addi x9'.
#
#     As seen in the simulation waveform ('hazard exp.jpg'),
#     these hazards did *not* cause stalls. They were
#     successfully resolved by the 'Hazard Unit' using
#     *forwarding* (or "bypassing").
#     - ForwardAE and ForwardBE signals (e.g., at cycle 5)
#       became '01' and '10', proving that results from the
#       MEM and WB stages were forwarded directly to the
#       ALU in the EX stage.
#
# * Control Hazards:
#     [cite_start]The program in 'memfile.hex' [cite: 560] contains no branch
#     or jump instructions (like 'beq', 'jal'). Therefore,
#     there were no control hazards, no mispredictions,
#     and no stall/flush cycles related to branches.
#
# In summary: Pipeline efficiency was only limited by the
# startup cost, not by any stalls from data or control hazards.